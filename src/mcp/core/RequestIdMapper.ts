import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { RequestId } from "@modelcontextprotocol/sdk/types.js";
import { createLogger } from '../../logger/index.js';

/**
 * Mapping entry, stores relationships between request IDs
 */
interface MappingEntry {
  originalRequestId: RequestId;        // Original request ID from upstream client
  proxyRequestId: string;              // Unique request ID generated by proxy layer
  downstreamRequestId?: RequestId;     // Request ID generated by downstream server
  serverId?: string;                   // Target server ID
  client?: Client;                     // Downstream client connection
  timestamp: number;                   // Creation timestamp
  method?: string;                     // Request method name
}

/**
 * RequestIdMapper - Manages multi-layer requestId mapping relationships
 * 
 * Solves problems:
 * - Multiple upstream clients may use the same requestId (all start from 0)
 * - Need to generate unique requestId at proxy layer to avoid conflicts
 * - Need to restore original requestId when responding
 * 
 * Mapping flow:
 * 1. Client → Proxy: originalRequestId → proxyRequestId
 * 2. Proxy → Server: proxyRequestId → downstreamRequestId
 * 3. Server → Proxy: downstreamRequestId → proxyRequestId
 * 4. Proxy → Client: proxyRequestId → originalRequestId
 */
export class RequestIdMapper {
  private sessionId: string;
  
  // Core mapping tables
  private clientToProxy: Map<RequestId, string> = new Map();
  private proxyToClient: Map<string, RequestId> = new Map();
  private proxyToDownstream: Map<string, MappingEntry> = new Map();
  private downstreamToProxy: Map<string, string> = new Map(); // downstreamId:serverId → proxyId
  
  // Cleanup related
  private cleanupTimer?: NodeJS.Timeout;
  private readonly TTL_MS = 5 * 60 * 1000; // 5 minute timeout
  private readonly CLEANUP_INTERVAL_MS = 60 * 1000; // Clean up every minute
  
  // Logger for RequestIdMapper
  private logger: ReturnType<typeof createLogger>;
  
  constructor(sessionId: string) {
    this.sessionId = sessionId;
    // Initialize logger with sessionId context
    this.logger = createLogger('RequestIdMapper', { sessionId: this.sessionId });
    this.startCleanupTimer();
  }
  
  /**
   * Generate unique proxy request ID
   * Format: sessionId:originalRequestId:timestamp
   */
  private generateProxyRequestId(originalRequestId: RequestId): string {
    const timestamp = Date.now();
    return `${this.sessionId}:${originalRequestId}:${timestamp}`;
  }
  
  /**
   * Register client request mapping
   * Called before forwarding request to downstream
   */
  registerClientRequest(
    originalRequestId: RequestId,
    method?: string,
    serverId?: string
  ): string {
    // Check if mapping already exists (may be retry)
    let proxyRequestId = this.clientToProxy.get(originalRequestId);
    
    if (!proxyRequestId) {
      // Generate new proxy request ID
      proxyRequestId = this.generateProxyRequestId(originalRequestId);
      
      // Establish bidirectional mapping
      this.clientToProxy.set(originalRequestId, proxyRequestId);
      this.proxyToClient.set(proxyRequestId, originalRequestId);
      
      // Create mapping entry
      const entry: MappingEntry = {
        originalRequestId,
        proxyRequestId,
        serverId,
        timestamp: Date.now(),
        method
      };
      
      this.proxyToDownstream.set(proxyRequestId, entry);
      
      this.logger.debug({ originalRequestId, proxyRequestId, method }, 'Registered client request');
    }
    
    return proxyRequestId;
  }
  
  /**
   * Register downstream response mapping
   * Called after receiving requestId assigned by downstream server
   */
  registerDownstreamMapping(
    proxyRequestId: string,
    downstreamRequestId: RequestId,
    serverId: string,
    client?: Client
  ): void {
    const entry = this.proxyToDownstream.get(proxyRequestId);
    
    if (entry) {
      // Update entry
      entry.downstreamRequestId = downstreamRequestId;
      entry.serverId = serverId;
      entry.client = client;
      
      // Establish reverse mapping (for handling responses)
      const downstreamKey = `${downstreamRequestId}:${serverId}`;
      this.downstreamToProxy.set(downstreamKey, proxyRequestId);
      
      this.logger.debug({ proxyRequestId, downstreamRequestId, serverId }, 'Registered downstream mapping');
    } else {
      this.logger.warn({ proxyRequestId }, 'No entry found for proxyRequestId');
    }
  }
  
  /**
   * Get proxy request ID by original client request ID
   */
  getProxyRequestId(originalRequestId: RequestId): string | undefined {
    return this.clientToProxy.get(originalRequestId);
  }
  
  /**
   * Get original client request ID by proxy request ID
   */
  getOriginalRequestId(proxyRequestId: string): RequestId | undefined {
    return this.proxyToClient.get(proxyRequestId);
  }
  
  /**
   * Get proxy request ID by downstream request ID and server ID
   */
  getProxyRequestIdFromDownstream(
    downstreamRequestId: RequestId,
    serverId: string
  ): string | undefined {
    const downstreamKey = `${downstreamRequestId}:${serverId}`;
    return this.downstreamToProxy.get(downstreamKey);
  }
  
  /**
   * Get complete mapping entry
   */
  getMappingEntry(proxyRequestId: string): MappingEntry | undefined {
    return this.proxyToDownstream.get(proxyRequestId);
  }
  
  /**
   * Get original request ID by downstream request ID (complete chain query)
   */
  getOriginalRequestIdFromDownstream(
    downstreamRequestId: RequestId,
    serverId: string
  ): RequestId | undefined {
    const proxyRequestId = this.getProxyRequestIdFromDownstream(downstreamRequestId, serverId);
    if (proxyRequestId) {
      return this.getOriginalRequestId(proxyRequestId);
    }
    return undefined;
  }
  
  /**
   * Remove specific mapping
   */
  removeMapping(proxyRequestId: string): void {
    const entry = this.proxyToDownstream.get(proxyRequestId);
    
    if (entry) {
      // Clean up all related mappings
      this.clientToProxy.delete(entry.originalRequestId);
      this.proxyToClient.delete(proxyRequestId);
      this.proxyToDownstream.delete(proxyRequestId);
      
      if (entry.downstreamRequestId && entry.serverId) {
        const downstreamKey = `${entry.downstreamRequestId}:${entry.serverId}`;
        this.downstreamToProxy.delete(downstreamKey);
      }
      
      this.logger.debug({ proxyRequestId }, 'Removed mapping');
    }
  }
  
  /**
   * Clean up expired mappings
   */
  private cleanupExpired(): number {
    const now = Date.now();
    let cleanedCount = 0;
    
    for (const [proxyRequestId, entry] of this.proxyToDownstream) {
      if (now - entry.timestamp > this.TTL_MS) {
        this.removeMapping(proxyRequestId);
        cleanedCount++;
      }
    }
    
    if (cleanedCount > 0) {
      this.logger.debug({ cleanedCount }, 'Cleaned up expired mappings');
    }
    
    return cleanedCount;
  }
  
  /**
   * Start periodic cleanup
   */
  private startCleanupTimer(): void {
    this.cleanupTimer = setInterval(() => {
      this.cleanupExpired();
    }, this.CLEANUP_INTERVAL_MS);
  }
  
  /**
   * Stop periodic cleanup
   */
  private stopCleanupTimer(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = undefined;
    }
  }
  
  /**
   * Get statistics
   */
  getStats(): {
    totalMappings: number;
    clientToProxy: number;
    proxyToDownstream: number;
    downstreamToProxy: number;
    oldestMapping?: { proxyRequestId: string; age: number };
  } {
    const now = Date.now();
    let oldest: { proxyRequestId: string; age: number } | undefined;
    
    for (const [proxyRequestId, entry] of this.proxyToDownstream) {
      const age = now - entry.timestamp;
      if (!oldest || age > oldest.age) {
        oldest = { proxyRequestId, age };
      }
    }
    
    return {
      totalMappings: this.proxyToDownstream.size,
      clientToProxy: this.clientToProxy.size,
      proxyToDownstream: this.proxyToDownstream.size,
      downstreamToProxy: this.downstreamToProxy.size,
      oldestMapping: oldest
    };
  }
  
  /**
   * Clear all mappings
   */
  clear(): void {
    const size = this.proxyToDownstream.size;
    
    this.clientToProxy.clear();
    this.proxyToClient.clear();
    this.proxyToDownstream.clear();
    this.downstreamToProxy.clear();
    
    this.logger.info({ size, sessionId: this.sessionId }, 'Cleared all mappings for session');
  }
  
  /**
   * Destroy mapper
   */
  destroy(): void {
    this.stopCleanupTimer();
    this.clear();
  }
}